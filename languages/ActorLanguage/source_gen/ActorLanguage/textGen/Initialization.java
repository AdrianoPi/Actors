package ActorLanguage.textGen;

/*Generated by MPS */

import jetbrains.mps.text.rt.TextGenContext;
import jetbrains.mps.text.impl.TextGenSupport;

public abstract class Initialization {
  public static void init(final TextGenContext ctx) {
    final TextGenSupport tgs = new TextGenSupport(ctx);
    tgs.append("#include <stdio.h>");
    tgs.newLine();
    tgs.append("#include <sys/ipc.h>");
    tgs.newLine();
    tgs.append("#include <sys/msg.h>");
    tgs.newLine();
    tgs.append("#include <pthread.h>");
    tgs.newLine();
    tgs.append("#include <string.h>");
    tgs.newLine();
    tgs.newLine();

    tgs.append("// this function returns, given the actor name, the id of the corresponding MQ ");
    tgs.newLine();
    tgs.append("int get_mqid(const char *string) {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.append("unsigned long hash = 5381;");
    tgs.newLine();
    tgs.append("int c;");
    tgs.newLine();
    tgs.newLine();
    tgs.append("while ((c = *str++)) {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.append("hash = ((hash << 5) + hash) + c;");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.append("}");
    tgs.newLine();
    tgs.newLine();
    tgs.append("return msgget(hash, 0666 | IPC_CREAT);");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.append("}");
    tgs.newLine();
    tgs.newLine();

    tgs.append("void create_thread(int address, map_item *map, void *(*start_routine) (void *), pthread_t *thread) {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.indent();
    tgs.append("ThreadData *thread_data = malloc(sizeof(ThreadData));");
    tgs.newLine();
    tgs.indent();
    tgs.append("if (!thread_data) {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.indent();
    tgs.append("perror(\"malloc\");");
    tgs.newLine();
    tgs.indent();
    tgs.append("exit(EXIT_FAILURE);");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.indent();
    tgs.append("}");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("int pipe_fd[2];");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("if (pipe(pipe_fd)) {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.indent();
    tgs.append("perror(\"pipe\");");
    tgs.newLine();
    tgs.indent();
    tgs.append("exit(EXIT_FAILURE);");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.indent();
    tgs.append("}");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("thread_data->read_fd = pipe_fd[0];");
    tgs.newLine();
    tgs.indent();
    tgs.append("thread_data->write_fd = pipe_fd[1];");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("pthread_mutex_lock(&map_mutex);");
    tgs.newLine();
    tgs.indent();
    tgs.append("map[address].write_fd = pipe_fd[1];");
    tgs.newLine();
    tgs.indent();
    tgs.append("if (pthread_mutex_init(&map[address].mutex, NULL) != 0) {");
    tgs.newLine();
    ctx.getBuffer().area().increaseIndent();
    tgs.indent();
    tgs.append("perror(\"pthread_mutex_init\");");
    tgs.newLine();
    tgs.indent();
    tgs.append("exit(EXIT_FAILURE);");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.indent();
    tgs.append("}");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("thread_data->map = map;");
    tgs.newLine();
    tgs.indent();
    tgs.append("pthread_mutex_unlock(&map_mutex);");
    tgs.newLine();
    tgs.newLine();

    tgs.indent();
    tgs.append("pthread_create(thread, NULL, start_routine, (void *)thread_data);");
    tgs.newLine();
    ctx.getBuffer().area().decreaseIndent();
    tgs.append("}");
    tgs.newLine();
    tgs.newLine();
  }
}
